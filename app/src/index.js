//⢯⣽⣿⣿⣿⠛⠉⠀⠀⠉⠉⢛⢟⡻⣟⡿⣿⢿⣿⣿⢿⣻⣟⡿⣟⡿⣿⣻⣟⣿⣟⣿⣻⣟⡿⣽⣻⠿⣽⣻⢟⡿⣽⢫⢯⡝
//⢯⣞⣷⣻⠤⢀⠀⠀⠀⠀⠀⠀⠀⠑⠌⢳⡙⣮⢳⣭⣛⢧⢯⡽⣏⣿⣳⢟⣾⣳⣟⣾⣳⢯⣽⣳⢯⣟⣷⣫⢿⣝⢾⣫⠗⡜
//⡿⣞⡷⣯⢏⡴⢀⠀⠀⣀⣤⠤⠀⠀⠀⠀⠑⠈⠇⠲⡍⠞⡣⢝⡎⣷⠹⣞⢧⡟⣮⢷⣫⢟⡾⣭⢷⡻⢶⣏⣿⢺⣏⢮⡝⢌
//⢷⣹⢽⣚⢮⡒⠆⠀⢰⣿⠁⠀⠀⠀⢱⡆⠀⠀⠈⠀⠀⠄⠁⠊⠜⠬⡓⢬⠳⡝⢮⠣⢏⡚⢵⢫⢞⡽⣏⡾⢧⡿⣜⡣⠞⡠
//⢏⣞⣣⢟⡮⡝⣆⢒⠠⠹⢆⡀⠀⢀⠼⠃⣀⠄⡀⢠⠠⢤⡤⣤⢀⠀⠁⠈⠃⠉⠂⠁⠀⠉⠀⠃⠈⠒⠩⠘⠋⠖⠭⣘⠱⡀
//⡚⡴⣩⢞⣱⢹⠰⡩⢌⡅⠂⡄⠩⠐⢦⡹⢜⠀⡔⢡⠚⣵⣻⢼⡫⠔⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⡄
//⡑⠦⡑⢎⡒⢣⢣⡑⢎⡰⢁⡒⢰⢠⢣⠞⢁⠢⡜⢢⢝⣺⡽⢮⠑⡈⠀⠀⠀⢀⡀⠀⣾⡟⠁⠀⠀⠠⡀⠀⠀⠀⠀⠀⠀⠐
//⢘⠰⡉⢆⠩⢆⠡⠜⢢⢡⠣⡜⢡⢎⠧⡐⢎⡱⢎⡱⢊⣾⡙⢆⠁⡀⠄⡐⡈⢦⢑⠂⠹⣇⠀⠀⠀⢀⣿⡀⠀⠀⠀⢀⠀⠄
//⠈⢆⠱⢈⠒⡈⠜⡈⢆⠢⢱⡘⣎⠞⡰⣉⠎⡴⢋⢰⣻⡞⣍⠂⢈⠔⡁⠆⡑⢎⡌⠎⢡⠈⠑⠂⠐⠋⠁⠀⠀⡀⢆⠠⣉⠂
//⡉⠔⡨⠄⢂⡐⠤⡐⣄⢣⢧⡹⡜⢬⡑⡌⢎⡵⢋⣾⡳⡝⠤⢀⠊⡔⡈⢆⡁⠮⡜⠬⢠⢈⡐⡉⠜⡠⢃⠜⣠⠓⣌⠒⠤⡁
//⢌⠢⢡⠘⡄⢎⡱⡑⢎⡳⢎⠵⡙⢆⠒⡍⡞⣬⢛⡶⡹⠌⡅⢂⠡⠐⠐⠂⠄⡓⠜⡈⢅⠢⠔⡡⢊⠔⡡⢚⠤⣋⠤⡉⠒⠠
//⢢⢑⢢⠱⡘⢦⠱⣉⠞⡴⢫⣜⡱⠂⡬⠜⣵⢊⠷⡸⠥⠑⡌⢂⠠⠃⢀⠉⠠⢜⠨⠐⡈⠆⡱⢀⠣⡘⠤⣉⠒⠄⠒⠠⢁⠡
//⢌⡚⡌⢆⠳⣈⠦⣛⠴⣓⠮⣝⠃⠐⡁⠖⣭⢚⡴⢃⠆⢢⠑⡌⠀⠀⠌⠐⠠⢜⠢⡀⠡⠐⠡⠘⠠⢁⠂⡉⠐⡀⠂⠄⡈⠄
//⠦⡱⡘⣌⠳⣌⠳⣌⠳⣍⠞⣥⢣⠀⠈⠑⠢⢍⠲⢉⠠⢁⠊⠀⠁⠀⠄⠡⠈⢂⠧⡱⣀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠐⠀⡀⠂
//⠂⠥⠑⡠⢃⠌⡓⢌⠳⢌⡹⢄⠣⢆⠀⠀⠀⠈⠀⠀⠀⠀⠀⠈⠀⠀⡌⢢⡕⡊⠔⢡⠂⡅⠂⠀⠀⠀⠀⠀⠐⠈⠀⢀⠀⠀
//⠈⠄⠡⠐⠠⠈⠔⣈⠐⢂⠐⡨⠑⡈⠐⡀⠀⠀⠀⠀⠀⠀⠀⡀⢤⡘⠼⣑⢎⡱⢊⠀⠐⡀⠁⠀⠀⠀⠐⠀⠀⢀⠀⠀⠀⠀
//⠀⠈⠄⡈⠄⣁⠒⡠⠌⣀⠒⠠⠁⠄⠡⢀⠁⠀⢂⠠⢀⠡⢂⠱⠢⢍⠳⣉⠖⡄⢃⠀⠀⠄⠂⠀⢀⠈⠀⢀⠈⠀⠀⠀⠀⠀
//⠀⡁⠆⠱⢨⡐⠦⡑⢬⡐⢌⢢⡉⢄⠃⡄⠂⠁⠠⠀⠄⠂⠄⠡⢁⠊⡑⠌⡒⢌⠢⢈⠀⠄⠂⠁⡀⠀⠂⡀⠄⠂⠀⠀⠀⠀
//⠤⠴⣒⠦⣄⠘⠐⠩⢂⠝⡌⢲⡉⢆⢣⠘⠤⣁⢂⠡⠌⡐⠈⠄⢂⠐⡀⠂⢀⠂⠐⠠⢈⠀⡐⠠⠀⠂⢁⠀⠀⠀⠀⠀⠀⠀
//⠌⠓⡀⠣⠐⢩⠒⠦⠄⣀⠈⠂⠜⡈⠦⠙⡒⢤⠃⡞⣠⠑⡌⠢⠄⢂⠐⠀⠀⠀⠀⠀⠀⠂⠀⠐⡀⠁⠠⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠁⡀⢈⠈⡑⠢⡙⠤⢒⠆⠤⢁⣀⠂⠁⠐⠁⠊⠔⠡⠊⠄⠂⢀⠀⠀⠀⠀⠀⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠁⠀⠀⠀⡀⠀⠀⠀⠈⠁⠊⠅⠣⠄⡍⢄⠒⠤⠤⢀⣀⣀⣀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠁⠀⠀⠁⠀⠂⠀⠄⠀⠀⠀⠈⠀⠉⠀⠁⠂⠀⠀⠉⠉⠩⢉⠢⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠂⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠁⠄⠀⠀⠀







// const { app, BrowserWindow, globalShortcut, ipcMain } = require('electron');
// const cls_pwnage = require('../sys/class_pwnage.js');
// const kb_util = require('../kbn/kbn_util.js');
// const path = require('path');


// The electron app shit itself
const electron = require('electron');
// Fuck JS (js class util)
const cls_pwnage = require('./sys/class_pwnage.js');
// Some common KickBoxer Node util
const kbn_util = require('./kbn/kbn_util.js');
const Path = kbn_util.Path;

// AT-AT Node
const atat_n = require('./kbn/node_atat.js');

// App's root dir
const KB_ROOT = Path(__dirname);


// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
	electron.app.quit();
}



// A very basic VMIX API manipulator
const BasicVMIX = class{
	IPC_MAP = Object.freeze([
		['kbn.basic_vmix.update_addr', 'update_addr'],
	]);

	constructor(kbn){
		const self = kbn_util.nprint(cls_pwnage.remap(this));

		// KickBoxer Node
		self.kbn = kbn;

		// VMIX IPV4 Address
		self.addr = {
			'ip': null,
			'port': null,
		}
	}

	init_ipc(self){
		for (const ipc_prms of self.IPC_MAP){
			const [ipc_id, tgt_func] = ipc_prms;
			electron.ipcMain.handle(ipc_id, function(event, args){
				self.nprint('IPC msg:', args);
				if (self[tgt_func]){
					self[tgt_func](args);
				}else{
					self.nprint('Invalid IPC CMD:', ipc_id);
				}
			});
		}

		self.nprint('IPC Init Done');
	}

	update_addr(self, data){
		self.nprint('Updating Address To:', data);
		self.addr.ip = data.ip || self.addr.ip;
		self.addr.port = data.port || self.addr.port;
	}

	create_api_url(self, rparams=null, with_scheme=false){
		const prms = new URLSearchParams(rparams || {});

		if (with_scheme){
			return `http://${self.addr.ip}:${self.addr.port}/API/?${prms.toString()}`
		}else{
			return `/API/?${prms.toString()}`
		}
	}

	talk(self, params){
		self.nprint(self.create_api_url(params, true));
		return fetch(
			self.create_api_url(params, true),
			{
				'headers': {
					'accept': '*/*',
					'cache-control': 'no-cache',
					'pragma': 'no-cache',
					'Access-Control-Allow-Origin': '*',
				},
				'method': 'GET',
				'mode': 'cors',
				'credentials': 'omit',
				'cache': 'no-store',
			}
		).catch(function(err){
			self.nprint('.talk() ERROR:', err);
		})
	}
}



const KickBoxer3000 = class{
	TERMINATE_IF_NO_WINDOWS = false;

	AUTO_OPEN_DEV_TOOLS = true;

	ENABLE_GLOBAL_CTRL_R = true;

	APP_ICON = KB_ROOT.join('assets', 'pink_panther.png').toString();

	IPC_MAP = Object.freeze([
		['kbn.main.reload', 'reload_main_window'],
	]);

	constructor(){
		const self = kbn_util.nprint(cls_pwnage.remap(this));

		// Browser window containing the DOM shit
		self.main_window = null;

		// AT-AT Node
		self.atat_n = new atat_n.NodeAtAtBundestag(self);
		self.atat_n.init_ipc();

		// Basic VMIX shit
		self.vmix = new BasicVMIX(self);
		self.vmix.init_ipc();
	}

	init_ipc(self){
		for (const ipc_prms of self.IPC_MAP){
			const [ipc_id, tgt_func] = ipc_prms;
			electron.ipcMain.handle(ipc_id, function(event, args){
				self.nprint('IPC msg:', args);
				if (self[tgt_func]){
					self[tgt_func](args);
				}else{
					self.nprint('Invalid IPC CMD:', ipc_id);
				}
			});
		}

		self.nprint('IPC Init Done');
	}

	// Dynamically link required JS files into the index HTML file
	rebuild_module_index(self){
		// modules_c dir
		const mdir = KB_ROOT.join('modules_c');

		const script_tags = [];

		for (const kb_module of mdir.globSync('*')){
			const tgt_js = kb_module.join(kb_module.basename + '.js');
			if (!tgt_js.isFileSync() || kb_module.join('ignore').isFileSync()){continue};
			script_tags.push(
				`<script src="./modules_c/${tgt_js.stem}/${tgt_js.basename}"></script>`
			)
		}

		KB_ROOT.join('index_autogen.html').writeFileSync(
			KB_ROOT.join('index.html')
			.readFileSync()
			.toString()
			.replace('@mscripts', script_tags.join('\n\t\t'))
		)
	}

	// pwn iframes, so that they don't complain about security
	unlock_iframes(self, tgt_window){
		tgt_window.webContents.session.webRequest.onHeadersReceived(
			{ urls: [ '*://*/*' ] },
			(d, c) => {
				if(d.responseHeaders['X-Frame-Options']){
					delete d.responseHeaders['X-Frame-Options'];
				} else if(d.responseHeaders['x-frame-options']) {
					delete d.responseHeaders['x-frame-options'];
				}

				c({cancel: false, responseHeaders: d.responseHeaders});
			}
		);

		tgt_window.webContents.session.webRequest.onBeforeSendHeaders((details, callback) => {
			details.requestHeaders['User-Agent'] = (
				  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '
				+ 'AppleWebKit/537.36 (KHTML, like Gecko) '
				+ 'Chrome/113.0.0.0 Safari/537.36'
			)
			callback({
				cancel: false,
				requestHeaders: details.requestHeaders
			});
		});
	}

	create_main_window(self){
		self.main_window = new electron.BrowserWindow({
			webPreferences: {
				nodeIntegration: true,
				contextIsolation: false,
				webviewTag: true,
			},
			width: 1280,
			height: 720,
			minWidth: 400,
			minHeight: 300,
			icon: self.APP_ICON,
			// frame: false,
			// titleBarOverlay: true,
			// transparent: true,
		});

		// Load the main HTML file
		self.main_window.loadFile(
			KB_ROOT.join('index_autogen.html').toString()
		);

		// Open the console
		if (self.AUTO_OPEN_DEV_TOOLS){
			self.main_window.webContents.openDevTools();
		}

		self.main_window.on('closed', () => {
			self.main_window = null;
		});
	}

	reload_main_window(self){
		self.main_window.reload();
	}

	create_tray(self){
		self.nprint('Creating Tray Menu');

		// Ensure Windows associates the tray icon & notifications with the app
		if (process.platform === 'win32') {
			electron.app.setAppUserModelId(process.execPath);
		}

		const tray = new electron.Tray(self.APP_ICON);
		tray.setToolTip('KickBoxer3000');

		tray.setContextMenu(electron.Menu.buildFromTemplate([
			{
				label: 'Show',
				click: () => {
					if (self.main_window){
						self.main_window.show();
					}else{
						self.create_main_window();
					}
				}
			},
			{
				label: 'Exit',
				click: () => {
					electron.app.quit();
				}
			}
		]));

		tray.on('double-click', () => {
			if (self.main_window){
				self.main_window.show();
			} else {
				self.create_main_window();
			}
		});

		self.nprint('Created Tray Menu');
	}

	// Some essential shit
	run(self){
		// What to do when all the browser windows got closed/crashed/whatever
		electron.app.on('window-all-closed', function(){
			self.nprint('All Browser Windows Closed');
			if (self.TERMINATE_IF_NO_WINDOWS){
				if (process.platform !== 'darwin') {
					app.quit();
				}
			}
		});

		// todo: is this Apple garbage really needed?
		electron.app.on('activate', function(){
			// On OS X it's common to re-create a window in the app when the
			// dock icon is clicked and there are no other windows open.
			if (electron.BrowserWindow.getAllWindows().length === 0) {
				self.create_main_window();
			}
		});

		// Remove the stupid menu uptop
		electron.app.on('browser-window-created', function(evt, window){
			window.removeMenu();
		});

		// This instance does the following if another instance is opened
		electron.app.on('second-instance', function(event, argv, workDir){
			self.nprint('Second instance attempted. Reusing this one');
			// If the window already exists - simply focus on it
			if (self.main_window){
				self.nprint('Window already exists. Focusing');
				if (self.main_window.isMinimized()){
					self.main_window.restore()
				}
				self.main_window.focus();
				return
			}else{
				// If it doesn't - create a new one
				self.nprint('No window exists. Creating a new one');
				self.create_main_window();
			}
		});

		if (self.ENABLE_GLOBAL_CTRL_R){
			electron.globalShortcut.register('CommandOrControl+R', function() {
				self.main_window?.reload?.();
			})
			electron.globalShortcut.register('CommandOrControl+Shift+I', function() {
				self.main_window?.webContents?.openDevTools?.();
			})
		}

		// Create tray menu
		self.create_tray();
	}
}



const main = function(){
	// If this is a second instance - terminate the process without any further actions
	if (!electron.app.requestSingleInstanceLock()){
		console.log('Second instance detected. Terminating');
		electron.app.quit();
		return
	}

	// Otherwise - launch kickboxer

	console.log('=========== Launching KickBoxer3000 ===========');

	const kickboxer = new KickBoxer3000();
	kickboxer.rebuild_module_index();
	kickboxer.init_ipc();
	kickboxer.run();
	kickboxer.create_main_window();
}



electron.app.on('ready', main);


